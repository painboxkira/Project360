import { useEffect, useState, useRef, useCallback, useMemo } from 'react';
import { useThree, useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import Viewer from './Viewer';
import LoadingScreen from './LoadingScreen';
import { dataManager } from './DataManager';
import type { ProcessedScene } from './processors/SceneProcessor';
import InfoHotspot from '../hotspots/InfoHotspot';
import { textureManager } from './TextureManager';
import LinkHotspot from '../hotspots/LinkHotspot';
import IntroHotspot from '../hotspots/IntroHotspot';
import QCUhotspot from '../hotspots/QCUhotspot';
import QCMhotspot from '../hotspots/QCMhotspot';
import StaticImg from '../hotspots/StaticImg';
import AudioManager from './AudioManager';
import AudioControls from './AudioControls';
import Layout from '../hotspots/ActiveAi/Rapport/Layout';

// Smooth camera rotation component
const SmoothCameraRotation = ({ targetPosition, isActive, orbitControlsRef }: {
    targetPosition: [number, number, number] | null;
    isActive: boolean;
    orbitControlsRef: React.RefObject<any>;
}) => {
    const animationRef = useRef<number | null>(null);
    const startTimeRef = useRef(0);
    const startPositionRef = useRef<THREE.Vector3 | null>(null);

    useEffect(() => {
        if (isActive && targetPosition && orbitControlsRef.current) {
            const controls = orbitControlsRef.current;
            
            startTimeRef.current = Date.now();
            startPositionRef.current = controls.object.position.clone();
            
            const targetVector = new THREE.Vector3(...targetPosition);
            const targetSpherical = new THREE.Spherical();
            targetSpherical.setFromVector3(targetVector);
            
            const targetCameraPosition = new THREE.Vector3();
            targetCameraPosition.setFromSphericalCoords(
                controls.getDistance(),
                Math.PI - targetSpherical.phi,
                targetSpherical.theta - Math.PI
            );
            targetCameraPosition.add(controls.target);
            
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
            }
            
            controls.enabled = false;
            
            const animate = () => {
                const elapsed = Date.now() - startTimeRef.current;
                const duration = 1000;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                
                controls.object.position.lerpVectors(
                    startPositionRef.current!,
                    targetCameraPosition,
                    easedProgress
                );
                
                controls.object.lookAt(controls.target);
                controls.update();
                
                if (progress < 1) {
                    animationRef.current = requestAnimationFrame(animate);
                } else {
                    animationRef.current = null;
                    controls.enabled = true;
                }
            };
            
            animationRef.current = requestAnimationFrame(animate);
        }
        
        return () => {
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
                if (orbitControlsRef.current) {
                    orbitControlsRef.current.enabled = true;
                }
            }
        };
    }, [isActive, targetPosition, orbitControlsRef]);

    return null;
};

// Camera-facing wrapper
const CameraFacingHotspot = ({ children, scale = [1, 1, 1] }: {
    children: React.ReactNode;
    scale?: [number, number, number];
}) => {
    const { camera } = useThree();
    const groupRef = useRef<THREE.Group>(null);

    useFrame(() => {
        if (groupRef.current && camera) {
            const distance = 2.5;
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const targetPosition = camera.position.clone().add(cameraDirection.multiplyScalar(distance));
            groupRef.current.position.copy(targetPosition);
            groupRef.current.lookAt(camera.position);
        }
    });

    return (
        <group ref={groupRef} scale={scale}>
            {children}
        </group>
    );
};

// Wrapper components with lookat behavior
const InfoHotspotWithLookat = ({ 
    texturePath, 
    position, 
    onComplete, 
    onActivate,
    isActive,
    onSetActive,
    onSetInactive
}: {
    texturePath: string[];
    position: [number, number, number];
    onComplete: () => void;
    onActivate: () => void;
    isActive: boolean;
    onSetActive: () => void;
    onSetInactive: () => void;
}) => {
    const groupRef = useRef<THREE.Group>(null);
    const { camera } = useThree();

    useFrame(() => {
        if (groupRef.current && camera) {
            groupRef.current.lookAt(camera.position);
        }
    });

    return (
        <group ref={groupRef} position={position}>
            <InfoHotspot 
                texturePath={texturePath}
                position={[0, 0, 0]} 
                onComplete={onComplete}
                onActivate={onActivate}
                isActive={isActive}
                onSetActive={onSetActive}
                onSetInactive={onSetInactive}
            />
        </group>
    );
};

const QCUHotspotWithLookat = ({ 
    texturePath, 
    position, 
    onComplete, 
    onActivate,
    isActive,
    onSetActive,
    onSetInactive,
    choices
}: {
    texturePath: string[];
    position: [number, number, number];
    onComplete: () => void;
    onActivate: () => void;
    isActive: boolean;
    onSetActive: () => void;
    onSetInactive: () => void;
    choices: any[];
}) => {
    const groupRef = useRef<THREE.Group>(null);
    const { camera } = useThree();

    useFrame(() => {
        if (groupRef.current && camera) {
            groupRef.current.lookAt(camera.position);
        }
    });

    return (
        <group ref={groupRef} position={position}>
            <QCUhotspot
                texturePath={texturePath}
                position={[0, 0, 0]}
                onComplete={onComplete}
                choices={choices}
                onActivate={onActivate}
                isActive={isActive}
                onSetActive={onSetActive}
                onSetInactive={onSetInactive}
            />
        </group>
    );
};

const QCMHotspotWithLookat = ({ 
    texturePath, 
    position, 
    onComplete, 
    onActivate,
    isActive,
    onSetActive,
    onSetInactive,
    choices,
    questionTexture
}: {
    texturePath: string[];
    position: [number, number, number];
    onComplete: () => void;
    onActivate: () => void;
    isActive: boolean;
    onSetActive: () => void;
    onSetInactive: () => void;
    choices: any[];
    questionTexture?: string;
}) => {
    const groupRef = useRef<THREE.Group>(null);
    const { camera } = useThree();

    useFrame(() => {
        if (groupRef.current && camera) {
            groupRef.current.lookAt(camera.position);
        }
    });

    return (
        <group ref={groupRef} position={position}>
            <QCMhotspot
                texturePath={texturePath}
                position={[0, 0, 0]}
                onComplete={onComplete}
                choices={choices}
                onActivate={onActivate}
                isActive={isActive}
                onSetActive={onSetActive}
                onSetInactive={onSetInactive}
                questionTexture={questionTexture}
            />
        </group>
    );
};

const LinkHotspotWithLookat = ({ 
    texturePath, 
    position, 
    onClickBehaviour, 
    onActivate 
}: {
    texturePath: string;
    position: [number, number, number];
    onClickBehaviour: () => void;
    onActivate: () => void;
}) => {
    const groupRef = useRef<THREE.Group>(null);
    const { camera } = useThree();

    useFrame(() => {
        if (groupRef.current && camera) {
            groupRef.current.lookAt(camera.position);
        }
    });

    const handleClick = useCallback((event: any) => {
        event.stopPropagation();
        onActivate();
        onClickBehaviour();
    }, [onActivate, onClickBehaviour]);

    return (
        <group ref={groupRef} position={position} onClick={handleClick}>
            <LinkHotspot 
                texturePath={texturePath}
                position={[0, 0, 0]} 
                onClickBehaviour={() => {}}
            />
        </group>
    );
};

const ActivAIHotspotWithLookat = ({ 
    position, 
    slug,
    isVisible
}: {
    position: [number, number, number];
    slug: string;
    isVisible: boolean;
}) => {
    const groupRef = useRef<THREE.Group>(null);
    const { camera } = useThree();

    useFrame(() => {
        if (groupRef.current && camera) {
            groupRef.current.lookAt(camera.position);
        }
    });

    return (
        <group ref={groupRef} position={position}>
            <Layout 
                slug={slug}
                position={[0, 0, 0]}
                isVisible={isVisible}
            />
        </group>
    );
};

const SceneViewer = ({ jsonPath }: { jsonPath: string }) => {
    const [sceneState, setSceneState] = useState({
        currentScene: null as ProcessedScene | null,
        isPreloading: true,
        completedHotspots: new Set<string>(),
        activeHotspotId: null as string | null,
        activeHotspotPosition: null as [number, number, number] | null,
        activeUIHotspotId: null as string | null,
        currentOrder: 0
    });
    
    const orbitControlsRef = useRef<any>(null);

    // Get all ordered hotspots across all scenes
    const allOrderedHotspots = useMemo(() => {
        if (!sceneState.currentScene) return [];
        
        const allScenes = dataManager.getAllScenes();
        const allHotspots = allScenes.flatMap(scene => 
            scene.hotspots?.map((hotspot: any) => ({
                ...hotspot,
                sceneId: scene.id
            })) || []
        );

        return allHotspots
            .filter((h: any) => h.order !== undefined)
            .sort((a: any, b: any) => a.order - b.order);
    }, [sceneState.currentScene]);

    // Get hotspots for current order
    const currentOrderHotspots = useMemo(() => {
        return allOrderedHotspots.filter((hotspot: any) => hotspot.order === sceneState.currentOrder);
    }, [allOrderedHotspots, sceneState.currentOrder]);

    // Get visible hotspots for current scene
    const visibleHotspots = useMemo(() => {
        if (!sceneState.currentScene) return [];

        return sceneState.currentScene.hotspots?.filter((hotspot: any) => {
            // If hotspot has no order, always show it
            if (hotspot.order === undefined) return true;
            
            // Show hotspot if it's in the current order
            return hotspot.order === sceneState.currentOrder;
        }) || [];
    }, [sceneState.currentScene, sceneState.currentOrder]);

    // Check if all required hotspots of current order are completed
    const allRequiredCompleted = useMemo(() => {
        const requiredHotspots = currentOrderHotspots.filter((hotspot: any) => 
            hotspot.required === true || 
            (hotspot.type === 'question' && (hotspot.subtype === 'qcu' || hotspot.subtype === 'qcm'))
        );
        
        return requiredHotspots.length === 0 || 
               requiredHotspots.every((hotspot: any) => sceneState.completedHotspots.has(hotspot.id));
    }, [currentOrderHotspots, sceneState.completedHotspots]);

    // Auto-advance order when all required hotspots are completed
    useEffect(() => {
        if (allRequiredCompleted && currentOrderHotspots.length > 0) {
            const hasNonLinkHotspots = currentOrderHotspots.some((h: any) => h.type !== 'link');
            if (hasNonLinkHotspots) {
                setSceneState(prev => ({
                    ...prev,
                    currentOrder: prev.currentOrder + 1
                }));
            }
        }
    }, [allRequiredCompleted, currentOrderHotspots]);

    // Debug logging
    useEffect(() => {
        console.log(`Current Order: ${sceneState.currentOrder}`);
        console.log(`Hotspots in current order: ${currentOrderHotspots.map((h: any) => `${h.id}(${h.type})`).join(', ')}`);
        console.log(`Visible hotspots in current scene: ${visibleHotspots.map((h: any) => h.id).join(', ')}`);
        console.log(`All required completed: ${allRequiredCompleted}`);
        console.log(`Current scene ID: ${sceneState.currentScene?.id}`);
    }, [sceneState.currentOrder, currentOrderHotspots, visibleHotspots, allRequiredCompleted, sceneState.currentScene]);

    // Load initial data
    useEffect(() => {
        const loadData = async () => {
            try {
                setSceneState(prev => ({ ...prev, isPreloading: true }));
                
                await dataManager.loadSceneData(jsonPath);
                const scene = dataManager.getCurrentScene();
                const allScenes = dataManager.getAllScenes();
                
                setSceneState(prev => ({ 
                    ...prev,
                    currentScene: scene,
                    currentOrder: 0
                }));

                if (allScenes.length > 0) {
                    await textureManager.preloadAllSceneTextures(allScenes);
                }
                
                setSceneState(prev => ({ ...prev, isPreloading: false }));
            } catch (error) {
                console.error('Failed to load scene data:', error);
                setSceneState(prev => ({ ...prev, isPreloading: false }));
            }
        };

        loadData();
    }, [jsonPath]);

    // Handle scene changes
    useEffect(() => {
        const unsubscribe = dataManager.subscribe((state) => {
            setSceneState(prev => {
                console.log(`Scene changed to: ${state.currentScene?.id}`);
                console.log(`Current order: ${prev.currentOrder}`);
                
                return {
                    ...prev,
                    currentScene: state.currentScene,
                    activeHotspotId: null,
                    activeHotspotPosition: null,
                    activeUIHotspotId: null
                };
            });
        });

        return unsubscribe;
    }, []);

    const handleSceneSwitch = useCallback((sceneId: string) => {
        const success = dataManager.switchToScene(sceneId);
        if (!success) {
            console.error('Failed to switch to scene:', sceneId);
        }
    }, []);

    const handleLinkClick = useCallback((sceneId: string) => {
        // Increment order for link hotspots
        setSceneState(prev => ({
            ...prev,
            currentOrder: prev.currentOrder + 1
        }));
        
        // Switch to the target scene
        handleSceneSwitch(sceneId);
    }, [handleSceneSwitch]);

    const handleHotspotActivate = useCallback((hotspotId: string, position: [number, number, number]) => {
        if (sceneState.activeHotspotId === hotspotId) {
            setSceneState(prev => ({ ...prev, activeHotspotId: null, activeHotspotPosition: null }));
        } else {
            setSceneState(prev => ({ ...prev, activeHotspotId: hotspotId, activeHotspotPosition: position }));
        }
    }, [sceneState.activeHotspotId]);

    const handleHotspotUIActivate = useCallback((hotspotId: string) => {
        setSceneState(prev => ({ ...prev, activeUIHotspotId: hotspotId }));
    }, []);

    const handleHotspotUIDeactivate = useCallback((hotspotId: string) => {
        setSceneState(prev => ({ ...prev, activeUIHotspotId: null }));
    }, []);

    const handleHotspotComplete = useCallback((hotspotId: string) => {
        setSceneState(prev => ({
            ...prev,
            completedHotspots: new Set([...prev.completedHotspots, hotspotId])
        }));
    }, []);

    const handleScenarioEnd = useCallback(() => {
        console.log('Scenario ended - user clicked Quitter');
    }, []);

    if (!sceneState.currentScene || !sceneState.currentScene.panoramaUrl) {
        return (
            <div style={{width: '100vw', height: '100vh', position: 'relative'}}>
                <LoadingScreen 
                    isVisible={sceneState.isPreloading}
                    onComplete={() => setSceneState(prev => ({ ...prev, isPreloading: false }))}
                />
            </div>
        );
    }

    return (
        <div style={{width: '100vw', height: '100vh', position: 'relative'}}>
            <AudioManager 
                audioConfig={sceneState.currentScene.audio || null}
                completedHotspots={sceneState.completedHotspots}
            />
            
            <AudioControls 
                audioConfig={sceneState.currentScene.audio || null}
                isVisible={false}
            />
            
            <Viewer 
                texturePath={sceneState.currentScene.panoramaUrl} 
                orbitControlsRef={orbitControlsRef}
            >
                <SmoothCameraRotation 
                    targetPosition={sceneState.activeHotspotPosition}
                    isActive={!!sceneState.activeHotspotId}
                    orbitControlsRef={orbitControlsRef}
                />

                {sceneState.currentScene.hotspots?.map((hotspot: any) => {
                    if (!visibleHotspots.some((h: any) => h.id === hotspot.id)) {
                        return null;
                    }

                    if (hotspot.type === 'intro') {
                        return (
                            <CameraFacingHotspot 
                                key={hotspot.id}
                                scale={[hotspot.size || 1, hotspot.size || 1, hotspot.size || 1]}
                            >
                                <IntroHotspot 
                                    texturePath={hotspot.texturePath}
                                    position={[0, 0, 0]}
                                    onComplete={() => handleHotspotComplete(hotspot.id)}
                                />
                            </CameraFacingHotspot>
                        );
                    }
                    
                    if (hotspot.type === 'question' && hotspot.subtype === 'qcu') {
                        return (
                            <QCUHotspotWithLookat
                                key={hotspot.id}
                                texturePath={hotspot.texturePath}
                                position={hotspot.position}
                                onComplete={() => handleHotspotComplete(hotspot.id)}
                                onActivate={() => handleHotspotActivate(hotspot.id, hotspot.position)}
                                isActive={sceneState.activeUIHotspotId === hotspot.id}
                                onSetActive={() => handleHotspotUIActivate(hotspot.id)}
                                onSetInactive={() => handleHotspotUIDeactivate(hotspot.id)}
                                choices={hotspot.choices}
                            />
                        );
                    }
                    
                    if (hotspot.type === 'question' && hotspot.subtype === 'qcm') {
                        return (
                            <QCMHotspotWithLookat
                                key={hotspot.id}
                                texturePath={hotspot.texturePath}
                                position={hotspot.position}
                                onComplete={() => handleHotspotComplete(hotspot.id)}
                                onActivate={() => handleHotspotActivate(hotspot.id, hotspot.position)}
                                isActive={sceneState.activeUIHotspotId === hotspot.id}
                                onSetActive={() => handleHotspotUIActivate(hotspot.id)}
                                onSetInactive={() => handleHotspotUIDeactivate(hotspot.id)}
                                choices={hotspot.choices}
                                questionTexture={hotspot.questionTexture}
                            />
                        );
                    }
                    
                    if (hotspot.type === 'info') {
                        return (
                            <InfoHotspotWithLookat 
                                key={hotspot.id}
                                texturePath={hotspot.texturePath}
                                position={hotspot.position} 
                                onComplete={() => handleHotspotComplete(hotspot.id)}
                                onActivate={() => handleHotspotActivate(hotspot.id, hotspot.position)}
                                isActive={sceneState.activeUIHotspotId === hotspot.id}
                                onSetActive={() => handleHotspotUIActivate(hotspot.id)}
                                onSetInactive={() => handleHotspotUIDeactivate(hotspot.id)}
                            />
                        );
                    }
                    
                    if (hotspot.type === 'link') {
                        return (
                            <LinkHotspotWithLookat 
                                key={hotspot.id} 
                                texturePath={hotspot.imagePath} 
                                position={hotspot.position} 
                                onClickBehaviour={() => handleLinkClick(hotspot.targetScene)}
                                onActivate={() => handleHotspotActivate(hotspot.id, hotspot.position)}
                            />
                        );
                    }
                    
                    if (hotspot.type === 'image') {
                        return (
                            <StaticImg 
                                key={hotspot.id} 
                                imagePath={hotspot.imagePath} 
                                position={hotspot.position} 
                                width={hotspot.width}
                                height={hotspot.height}
                            />
                        );
                    }

                    if (hotspot.type === 'activai') {
                        return (
                            <ActivAIHotspotWithLookat
                                key={hotspot.id}
                                position={hotspot.position}
                                slug={hotspot.slug}
                                isVisible={true}
                            />
                        );
                    }

                    return null;
                })}
            </Viewer>
            
            <LoadingScreen 
                isVisible={sceneState.isPreloading}
                onComplete={() => setSceneState(prev => ({ ...prev, isPreloading: false }))}
            />
        </div>
    );
};

export default SceneViewer;